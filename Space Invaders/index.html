<html>
	<head>
		<title>Space Invaders by Martin Nilsson</title>
		<style>
			p {
				font-size:12px;
				font-family: consolas;
			}
			h1 {
				font-size:32px;
				font-family: consolas;
				font-weight: bold;
			}
		</style>
	</head>
	<body>
		<h1>Space Invaders</h1>
		<canvas id="myCanvas" width="500" height="400" style="border:2px solid black;"></canvas>
		<p>Controls: SPACE or NUM_0 to fire. Move with arrowkeys or "W" and "D"</p>
		<script>
			/*KNOWN BUGS
			 * If you fire at the far left corner, the enemies left counter goes down for some reason. It can remove up to 6 in that counter.
			 * the first middle breakable wall in the middle column breaks on only two hits. None of the others have this problem
			 * You can seemingly randomly lose a life from either an invisible bullet or broken hit detection.


			 TODO:
			 * Add movement to enemies
			 * Fix hit detection between enemy bullets and the breakable walls.
			 */

			var canvas = document.getElementById("myCanvas");
			var ctx = canvas.getContext("2d");

			//player variablesa
			var playerHeight = 30;
			var playerWidth = 30;
			var playerX = (canvas.width-playerWidth)/2;
			var playerY = (canvas.height-playerHeight)-20;
			var hull = 5;

			//movement variables
			var x = canvas.width/2;
			var y = canvas.height-30
			var dx = 2;
			var dy = -2;
			var right = false;
			var left = false;

			//bullet variables 
			var bulletX = playerX+(playerWidth/2);
			var bulletY = playerY;
			var bulletSize = 3;
			var gunIsLoaded = true;

			//bullet movement
			var bulletPos = bulletY;
			var bulletSpeed = 9

			//enemy variables
			var enemyColumnCount = 11;
			var enemyRowCount = 3;
			var enemyWidth = 30;
			var enemyHeight = 30;
			var enemyPadding = 5;
			var enemyOffsetTop = 50;
			var enemyOffsetLeft = ((canvas.width - (enemyWidth * enemyColumnCount)) - enemyPadding * enemyColumnCount)/2;
			var enemiesLeft = 9 * 3;
			var enemyReloadSpeed = 200;

			//image resource
			var enemy_image = new Image();
			enemy_image.src = "resources/images/space_invader_001.png";
			var player_image = new Image();
			player_image.src = "resources/images/space_invader_player.png"

			//enemy objects
			var enemies = [];
			for (c = 0; c < enemyColumnCount; c++) {
				enemies[c] = [];
				for (r = 0; r < enemyRowCount; r++) {
					enemies[c][r] = {
						x: 0,
						y: 0,
						status: 1,
						bulletX: ((c * (enemyWidth + enemyPadding)) + enemyOffsetLeft+playerWidth/2),
						bulletY: ((r * (enemyHeight + enemyPadding)) + enemyOffsetTop)+playerHeight,
						fire: true,
						temp: bulletY,
						reloaded: true
					};
				}
			}

			//breakable wall variables
			var breakableColCount = 13;
			var breakableRowCount = 2;
			var breakableWidth = 20;
			var breakableHeight = 10;
			var breakablePadding = 1;
			var breakableOffsetTop = canvas.height - (breakableRowCount * breakableHeight) - (breakablePadding * breakableRowCount) - 60;
			var breakableOffsetLeft = ((canvas.width - (breakableWidth * breakableColCount)) - breakablePadding*enemyColumnCount)/2;

			//breakable objects
			var breakable = [];
			for (c = 0; c < breakableColCount; c++) {
				breakable[c] = [];
				for (r = 0; r < breakableRowCount; r++) {
					breakable[c][r] = {
						x: 0, 
						y: 0, 
						status: 3
					};
				}
			}

			//movement handling
			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);

			function keyUpHandler(e) {
			    if(e.keyCode == 39 || e.keyCode == 68) {
			        right = false;
			    } else if(e.keyCode == 37 || e.keyCode == 65) {
			        left = false;
			    }
			}

			function keyDownHandler(e) {
			    if(e.keyCode == 39 ||  e.keyCode == 68) {
			        right = true;
			    } else if(e.keyCode == 37  || e.keyCode == 65) {
			        left = true;
			    } else if(e.keyCode == 32 || e.keyCode == 96) {
			    	if (gunIsLoaded) {
			    		bulletX = playerX+(playerWidth/2);
				    	bulletPos = bulletY;
			    		setInterval(drawPlayerBullet,10);	
			    		gunIsLoaded = false;
			    		setTimeout(reloadGun, 700);
			    	}
			    }
			}

			function drawEnemyBoard() {
				ctx.font = "16px Consolas";
				ctx.fillStyle = "black";
				ctx.fillText("Enemies left: " + enemiesLeft, 10, canvas.height-10); 
			}

			function drawLivesBoard() {
				ctx.font = "16px Consolas";
				ctx.fillStyle = "black";
				ctx.fillText("Hull armor: " + hull, 180, canvas.height-10); 
			}

			function drawPlayerBullet() {
				ctx.beginPath();
				ctx.arc(bulletX, bulletPos, bulletSize, 0, 2*Math.PI);
				ctx.fillStyle = "black";
				ctx.fill();
				ctx.closePath();
			}

			function reloadGun() {
				gunIsLoaded = true;
			}

			function drawPlayer() {
				ctx.beginPath();
				//ctx.rect(playerX, playerY, playerWidth, playerHeight);
				//ctx.stroke();
				ctx.drawImage(player_image, playerX, playerY);
				ctx.closePath();
			}

			function drawEnemies() {
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
						if (enemies[c][r].status == 1) {
							if (c == 3 || c == 7) continue; 
							var enemyX = (c * (enemyWidth + enemyPadding)) + enemyOffsetLeft;
							var enemyY = (r * (enemyHeight + enemyPadding)) + enemyOffsetTop;
							enemies[c][r].x = enemyX;
							enemies[c][r].y = enemyY;
							ctx.beginPath();
							//ctx.rect(enemyX, enemyY, enemyWidth, enemyHeight);
							//ctx.fillStyle = "black";
							//ctx.fill();
							ctx.drawImage(enemy_image, enemyX, enemyY);
							ctx.closePath();						
						}	

					}
				}
			}

			function enemyFire(rc, rr) {
				if (enemies[rc][rr].status == 1) {
					if (enemies[rc][rr].reloaded) {
			    		enemies[rc][rr].temp = enemies[rc][rr].bulletY;	
						requestAnimationFrame(drawEnemyBullet);
						enemies[rc][rr].reloaded = false;
						setTimeout(reloadEnemyGun, 10);
					}	
				}	
			}

			function drawEnemyBullet() {
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
						if (c == 3 || c == 7) continue;
						ctx.beginPath();
						ctx.arc(enemies[c][r].bulletX, enemies[c][r].temp, bulletSize, 0, 2*Math.PI); //bulletY isnt resetting so they can only shoot once atm
						ctx.fillStyle = "red";
						ctx.fill();
						ctx.closePath();
					}
				}
			}
			function reloadEnemyGun() {
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
						enemies[c][r].reloaded = true;
					}
				}
			}

			function drawBreakableWalls() {
				for (c = 0; c < breakableColCount; c++) {
					for (r = 0; r < breakableRowCount; r++) {
						if (breakable[c][r].status > 0) {
							//cluster them into three by removing columns 3,4,8 and 9. Ugly bruteforced solution but it works :D
							if (c == 3 || c == 4 || c == 8 || c == 9) continue;
							var breakableX = (c * (breakableWidth + breakablePadding)) + breakableOffsetLeft;
							var breakableY = (r * (breakableHeight + breakablePadding)) + breakableOffsetTop;
							breakable[c][r].x = breakableX;
							breakable[c][r].y = breakableY;
							ctx.beginPath();
							ctx.rect(breakableX, breakableY, breakableWidth, breakableHeight);
							ctx.fillStyle = "black";
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			}

			function move() {
				if(right && playerX < canvas.width-playerWidth) {
			        playerX += 7;
			    } else if(left && playerX > 0) {
			        playerX -= 7;
			    }
			    
			    x += dx;
			    y += dy;
			}



			function enemyCollisionBreakable() { // doesnt work
				for (c = 0; c < breakableColCount; c++) {
					for (r = 0; r < breakableRowCount; r++) {
						for (ec = 0; ec < enemyColumnCount; ec++) {
							for (er = 0; er < enemyRowCount; er++) {
								var b = breakable[c][r];
								var e = enemies[ec][er];
								if (b.status > 0) {
		       	     				if(e.bulletX > b.x && e.bulletX < b.x + breakableWidth && e.temp == b.y) {
				            			e.bulletX = 10000000;
				            			b.status--; 
					            	}
				       	     	}
							}
						}
					}
				}
			}

			function enemyCollisionPlayer() {
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
	       	     		if(enemies[c][r].bulletX > playerX && enemies[c][r].bulletX < playerX + playerWidth && enemies[c][r].temp > playerY && enemies[c][r].temp < playerY + enemyHeight) {
			            	enemies[c][r].bulletX = 10000000; 
			            	hull--;
			            	console.log(hull);
			            	if (hull == 0) {
			            		alert("game over");
			            	}			            	
		            	}
					}
				}
			}

			function playerCollisionEnemy() {
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
						var e = enemies[c][r];
		       	     	if (e.status == 1) {
		       	     		if(bulletX > e.x && bulletX < e.x + enemyWidth && bulletPos > e.y && bulletPos < e.y + enemyHeight) {
				            	//ctx.clearRect(0, 0, canvas.width, canvas.height); //Cool blinking effect on hit
				            	bulletX = 10000000; //weird solution to make it look like the shot disappears o_0
				            	e.status--;
				            	enemiesLeft--;
				            	if (enemiesLeft == 0) {
				            		alert("lol u won");
				            	}
			            	}
		       	     	}
					}
				}
			}

			function playerCollisionBreakable() {
				for (c = 0; c < breakableColCount; c++) {
					for (r = 0; r < breakableRowCount; r++) {
						var b = breakable[c][r];
		       	     	if (b.status > 0) {
		       	     		if(bulletX > b.x && bulletX < b.x + breakableWidth && bulletPos > b.y && bulletPos < b.y + breakableHeight) {
			            		bulletX = 10000000;
			            		b.status--; 
			            	}
		       	     	}
					}
				}
			}

			function main() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				//player bullet movement
				bulletPos -= bulletSpeed; 
				//enemy bullet movement
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
						if (enemies[c][r].fire) {
								enemies[c][r].temp += bulletSpeed;
						}
					}
				}

				drawPlayer();
				drawEnemies();
				drawBreakableWalls();
				drawEnemyBullet(); //is buggy but currently required. 
				move();	
				enemyCollisionBreakable();
				enemyCollisionPlayer();
				playerCollisionEnemy();
				playerCollisionBreakable();

				drawEnemyBoard();
				drawLivesBoard();
				
				requestAnimationFrame(main);	

			}

			main();
			setInterval(function() { 
				var rc = Math.floor((Math.random() * enemyColumnCount) + 1);
				var rr = Math.floor((Math.random() * enemyRowCount) + 1);		
				enemyFire(rc, rr);
			},enemyReloadSpeed);

		</script>
	</body>
</html>