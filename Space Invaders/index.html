<html>
	<head>
		<title>Space Invaders by Martin Nilsson</title>
		<style>
			p {
				font-size:12px;
				font-family: consolas;
			}
			h1 {
				font-size:32px;
				font-family: consolas;
				font-weight: bold;
				margin-bottom:0;
				padding-bottom:0;
			}
		</style>
	</head>
	<body>
		<h1>Space Invaders</h1>
		<p>by Martin Nilsson</p>
		<canvas id="myCanvas" width="500" height="400" style="border:2px solid black;"></canvas>
		<p><b>Controls:</b> SPACE or RIGHT CTRL to fire. Move with arrowkeys or 'A' and 'D'</p>
		<script>
			/*KNOWN BUGS
			 * If you fire at the far left corner, the enemies left counter goes down for some reason. It can remove up to 6 in that counter.
			 * the first middle breakable wall in the middle column breaks on only two hits. None of the others have this problem
			 * You can seemingly randomly lose a life from either an invisible bullet or broken hit detection.


			 TODO:
			 * Add movement to enemies
			 * Fix hit detection between enemy bullets and the breakable walls.
			 */

			var canvas = document.getElementById("myCanvas");
			var ctx = canvas.getContext("2d");

			//player variablesa
			var playerHeight = 30;
			var playerWidth = 30;
			var playerX = (canvas.width-playerWidth)/2;
			var playerY = (canvas.height-playerHeight)-20;
			var hull = 5;

			//movement variables
			var x = canvas.width/2;
			var y = canvas.height-30
			var dx = 2;
			var dy = -2;
			var right = false;
			var left = false;

			//bullet variables 
			var bulletX = playerX+(playerWidth/2);
			var bulletY = playerY;
			var bulletSize = 10;
			var gunIsLoaded = true;

			//bullet movement
			var bulletPos = bulletY;
			var bulletSpeed = 9

			//enemy variables
			var enemyColumnCount = 11;
			var enemyRowCount = 3;
			var enemyWidth = 30;
			var enemyHeight = 30;
			var enemyPadding = 5;
			var enemyOffsetTop = 50;
			var enemyOffsetLeft = ((canvas.width - (enemyWidth * enemyColumnCount)) - enemyPadding * enemyColumnCount)/2;
			var enemiesLeft = 9 * 3;
			var enemyReloadSpeed = 200;

			var bullets = [];
			var bullet_id = 0;

			var enemy_sprites = [];
			enemy_sprites[0] = {offset_pixels: {x: 4, y: 7},
								matrix: [
										[0,4], [0, 5], [0, 6], [0, 7],
										[1, 3], [1, 4],
										[2, 0], [2, 2], [2, 3], [2, 4], [2, 5], [2, 6], [2, 7],
										[3, 1], [3, 2], [3, 4], [3, 5], [3, 6], [3, 8], // Left eye
										[4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 8],
										[5, 2], [5, 3], [5, 4], [5, 5], [5, 6], // Center piece || From now on, we could just mirror this.
										[6, 2], [6, 3], [6, 4], [6, 5], [6, 6], [6, 8],
										[7, 1], [7, 2], [7, 4], [7, 5], [7, 6], [7, 8], // Righ eye
										[8, 0], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7],
										[9, 3], [9, 4],
										[10,4], [10, 5], [10, 6], [10, 7],
										]};

			var player_image = new Image();
			player_image.src = "resources/images/space_invader_player.png"

			//enemy objects
			var enemies = [];
			for (c = 0; c < enemyColumnCount; c++) {
				enemies[c] = [];
				for (r = 0; r < enemyRowCount; r++) {
					enemies[c][r] = {
						x: 0,
						y: 0,
						status: 1,
						bulletX: ((c * (enemyWidth + enemyPadding)) + enemyOffsetLeft+playerWidth/2),
						bulletY: ((r * (enemyHeight + enemyPadding)) + enemyOffsetTop)+playerHeight,
						fire: true,
						temp: bulletY,
						reloaded: true
					};
				}
			}

			//breakable wall variables
			var breakableColCount = 13;
			var breakableRowCount = 2;
			var breakableWidth = 20;
			var breakableHeight = 10;
			var breakablePadding = 1;
			var breakableOffsetTop = canvas.height - (breakableRowCount * breakableHeight) - (breakablePadding * breakableRowCount) - 60;
			var breakableOffsetLeft = ((canvas.width - (breakableWidth * breakableColCount)) - breakablePadding*enemyColumnCount)/2;

			//breakable objects
			var breakable = [];
			for (c = 0; c < breakableColCount; c++) {
				breakable[c] = [];
				for (r = 0; r < breakableRowCount; r++) {
					breakable[c][r] = {
						x: 0, 
						y: 0, 
						status: 3
					};
				}
			}

			//movement handling
			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);

			function keyUpHandler(e) {
				if(e.keyCode == 39 || e.keyCode == 68) {
					right = false;
				} else if(e.keyCode == 37 || e.keyCode == 65) {
					left = false;
				}
			}

			function keyDownHandler(e) {
				if(e.keyCode == 39 ||  e.keyCode == 68) {
					right = true;
				} else if(e.keyCode == 37  || e.keyCode == 65) {
					left = true;
				} else if(e.keyCode == 32 || e.keyCode == 17) {
					if (gunIsLoaded) {
						bulletX = playerX+(playerWidth/2);
						bulletPos = bulletY;
						setInterval(drawPlayerBullet,10);	
						gunIsLoaded = false;
						setTimeout(reloadGun, 700);
					}
				}
			}

			function drawEnemyBoard() {
				ctx.font = "16px Consolas";
				ctx.fillStyle = "black";
				ctx.fillText("Enemies left: " + enemiesLeft, 10, canvas.height-10); 
			}

			function drawLivesBoard() {
				ctx.font = "16px Consolas";
				ctx.fillStyle = "black";
				ctx.fillText("Hull armor: " + hull, 180, canvas.height-10); 
			}

			function drawPlayerBullet() {
				ctx.beginPath();
				ctx.arc(bulletX, bulletPos, bulletSize, 0, 2*Math.PI);
				ctx.fillStyle = "black";
				ctx.fill();
				ctx.closePath();
			}

			function reloadGun() {
				gunIsLoaded = true;
			}

			function drawPlayer() {
				ctx.beginPath();
				//ctx.rect(playerX, playerY, playerWidth, playerHeight);
				//ctx.stroke();
				ctx.drawImage(player_image, playerX, playerY);
				ctx.closePath();
			}

			function drawEnemies() {
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
						if (enemies[c][r].status == 1) {
							if (c == 3 || c == 7) continue; 
							var enemyX = (c * (enemyWidth + enemyPadding)) + enemyOffsetLeft;
							var enemyY = (r * (enemyHeight + enemyPadding)) + enemyOffsetTop;
							enemies[c][r].x = enemyX;
							enemies[c][r].y = enemyY;

							ctx.beginPath();
							
							var scale = 2;
							for(var i=0; i<enemy_sprites[0].matrix.length; i++) {
								// Use the:
								//      overall enemy X position
								//    + offset.x (to center the image)
								//    + matrix pixel-art position ([0] being x and [1] being y)
								//    * scale
								var x = enemyX + enemy_sprites[0].offset_pixels.x + (enemy_sprites[0].matrix[i][0] * scale);
								var y = enemyY + enemy_sprites[0].offset_pixels.y + (enemy_sprites[0].matrix[i][1] * scale);

								ctx.rect(x, y, 1*scale, 1*scale);
							}
							
							ctx.fillStyle = "black";
							ctx.fill();
							//ctx.drawImage(enemy_image, enemyX, enemyY);
							ctx.closePath();						
						}	

					}
				}
			}

			function enemyFire(rc, rr) {
				if (enemies[rc][rr].status == 1) {
					if (enemies[rc][rr].reloaded) {
						// Instead of having a bullet "value" on each enemy object.
						// We create a array of bullets, where each bullet has a few values.
						// bullet.x is the X position, bullet.y is the bullet Y position etc.
						bullets[bullet_id++] = {x: enemies[rc][rr].bulletX,
													y: enemies[rc][rr].bulletY,
													speed : bulletSpeed,
													firing: enemies[rc][rr]};

						//enemies[rc][rr].temp = enemies[rc][rr].bulletY;	
						requestAnimationFrame(drawEnemyBullet);
						enemies[rc][rr].reloaded = false;
						setTimeout(reloadEnemyGun, 10);
					}	
				}	
			}

			function drawEnemyBullet() {
				for (var index=0; index<bullet_id; index++) {
					if(bullets[index] === undefined)
						continue;

					ctx.beginPath();
					ctx.arc(bullets[index].x, bullets[index].y, bulletSize, 0, 2*Math.PI);
					ctx.fillStyle = "red";
					ctx.fill();
					ctx.closePath();

					bullets[index].y += bullets[index].speed;
					var bullet_collided = false;

					// First, we iterate over the breakables,
					// we check if a bullet hit one of them.
					for (c = 0; c < breakableColCount; c++) {
						for (r = 0; r < breakableRowCount; r++) {
							if (breakable[c][r].status > 0) {
								// Collision detection:
								// if y of the bullet is larger than y of the breakable, AND lower than breakableY+height, we're inside the breakable.
								if(enemyCollisionBreakable(bullets[index], breakable[c][r])) {
									delete(bullets[index]);
									bullet_collided = true;
									break;
								}
							}
						}
						// Since the bullet collided, we can skip the rest of the breakables.
						if(bullet_collided)
							break;
					}
					// Since the bullet collided, we can skip to check if we hit the player.
					if(bullet_collided)
						break;

					// IF it didn't, we will check if the bullet hit the player.
					if(enemyCollisionPlayer(bullets[index])) {
						hull--;
						delete(bullets[index]);
						if (hull == 0) {
							alert('Game over! GAME OVER MAN!');
						}
					}
				}
			}
			function reloadEnemyGun() {
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
						enemies[c][r].reloaded = true;
					}
				}
			}

			function drawBreakableWalls() {
				for (c = 0; c < breakableColCount; c++) {
					for (r = 0; r < breakableRowCount; r++) {
						if (breakable[c][r].status > 0) {
							//cluster them into three by removing columns 3,4,8 and 9. Ugly bruteforced solution but it works :D
							if (c == 3 || c == 4 || c == 8 || c == 9) continue;
							var breakableX = (c * (breakableWidth + breakablePadding)) + breakableOffsetLeft;
							var breakableY = (r * (breakableHeight + breakablePadding)) + breakableOffsetTop;
							breakable[c][r].x = breakableX;
							breakable[c][r].y = breakableY;
							ctx.beginPath();
							ctx.rect(breakableX, breakableY, breakableWidth, breakableHeight);
							ctx.fillStyle = "black";
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			}

			function move() {
				if(right && playerX < canvas.width-playerWidth) {
					playerX += 7;
				} else if(left && playerX > 0) {
					playerX -= 7;
				}
				
				x += dx;
				y += dy;
			}

			function enemyCollisionBreakable(bullet, breakable) { // doesnt work
				if(bullet.y >= breakable.y && bullet.y <= breakable.y+breakableHeight) {
					if (bullet.x >= breakable.x && bullet.x <= breakable.x+breakableWidth) {
						return true;
					}
				}
			}

			function enemyCollisionPlayer(bullet) {
				if(bullet.y >= playerY && bullet.y <= playerY+playerHeight) {
					if(bullet.x >= playerX && bullet.x <= playerX+playerWidth) {
						return true;
					}
				}
			}

			function playerCollisionEnemy() {
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
						var e = enemies[c][r];
						if (e.status == 1) {
							if(bulletX > e.x && bulletX < e.x + enemyWidth && bulletPos > e.y && bulletPos < e.y + enemyHeight) {
								//ctx.clearRect(0, 0, canvas.width, canvas.height); //Cool blinking effect on hit
								bulletX = 10000000; //weird solution to make it look like the shot disappears o_0
								e.status--;
								enemiesLeft--;
								if (enemiesLeft == 0) {
									alert("lol u won");
								}
							}
						}
					}
				}
			}

			function playerCollisionBreakable() {
				for (c = 0; c < breakableColCount; c++) {
					for (r = 0; r < breakableRowCount; r++) {
						var b = breakable[c][r];
						if (b.status > 0) {
							if(bulletX > b.x && bulletX < b.x + breakableWidth && bulletPos > b.y && bulletPos < b.y + breakableHeight) {
								bulletX = 10000000;
								b.status--; 
							}
						}
					}
				}
			}

			function main() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				//player bullet movement
				bulletPos -= bulletSpeed; 
				//enemy bullet movement
				for (c = 0; c < enemyColumnCount; c++) {
					for (r = 0; r < enemyRowCount; r++) {
						if (enemies[c][r].fire) {
							enemies[c][r].temp += bulletSpeed;
						}
					}
				}

				drawPlayer();
				drawEnemies();
				drawBreakableWalls();
				drawEnemyBullet(); //is buggy but currently required. atm it also creates one shot from all enemies right at the spawn point of the player
				move();	
				// These are now called in the drawEnemyBullet()
				//enemyCollisionBreakable();
				//enemyCollisionPlayer();
				playerCollisionEnemy();
				playerCollisionBreakable();

				drawEnemyBoard();
				drawLivesBoard();
				
				requestAnimationFrame(main);	

			}

			main();
			setInterval(function() { 
				var rc = Math.floor((Math.random() * enemyColumnCount));
				var rr = Math.floor((Math.random() * enemyRowCount));
				enemyFire(rc, rr);
			},enemyReloadSpeed);

		</script>
	</body>
</html>